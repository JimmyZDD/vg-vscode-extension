
/*
 * @Author: zdd
 * @Date: 2023-05-31 22:05:06
 * @LastEditors: zdd
 * @LastEditTime: 2023-06-02 16:01:32
 * @FilePath: /vg-vscode-extension/src/swagger-generator/dart/generate/model.ts
 * @Description: 
 */
import { existsSync, writeFile } from "fs";
import * as changeCase from "change-case";
import { mkdirpSync } from "mkdirp";
import { join } from "path";

import type { SwaggerSchema, SwaggerSchemas } from "../../index.d";
import { BASE_TYPE, INDENT, exchangeZhToEn, getDartType } from "../../utils";

class ModelGenerate {
  data: SwaggerSchemas;
  options: { rootPath: string, translateJson: Record<string, string> };
  filesMap: Record<string, string>;

  constructor(data: SwaggerSchemas, options: { rootPath: string, translateJson: Record<string, string> }) {
    this.options = options;
    this.data = data;
    this.filesMap = {};
  }

  async generateAllModel() {
    for (let key in this.data)
      this.generateModel(key, this.data[key]) + "\n";


    let str = 'library entitys;\n\n';
    const modelsDir = join(this.options.rootPath, 'entitys');
    for (let key in this.filesMap) {
      str += `export '.${key.replace(modelsDir, '')}/model.g.dart';\n`;
      if (!existsSync(join(key, 'model.g.dart')))
        // model内容写入
        writeFile(
          join(key, 'model.g.dart'),
          this.filesMap[key],
          'utf-8',
          (error: any) => {
            // if (error)
            //   reject(error);
            // else
            //   resolve("写入成功");
          }
        );
      else
        // model内容写入
        writeFile(
          join(key, 'model.g.vg'),
          this.filesMap[key],
          'utf-8',
          (error: any) => {
            // if (error)
            //   reject(error);
            // else
            //   resolve("写入成功");
          }
        );
    }
    if (!existsSync(join(modelsDir, 'index.dart')))
      writeFile(
        join(modelsDir, 'index.dart'),
        str,
        'utf-8',
        (error: any) => {
          // if (error)
          //   reject(error);
          // else
          //   resolve("写入成功");
        }
      );
    writeFile(
      join(modelsDir, 'index.text'),
      str,
      'utf-8',
      (error: any) => {
        // if (error)
        //   reject(error);
        // else
        //   resolve("写入成功");
      }
    );

  }
  generateModel(key: string, value: SwaggerSchema) {
    const folder = value["x-apifox-folder"];
    let dirPath: string;

    if (folder) {
      const { str: path } = exchangeZhToEn(folder, this.options.translateJson);
      dirPath = join(this.options.rootPath, 'entitys', path.split('/').map(e => changeCase.snakeCase(e)).join('/'));
    } else {
      dirPath = join(this.options.rootPath, 'entitys');
    }

    if (!existsSync(dirPath)) mkdirpSync(dirPath);
    const className = changeCase.pascalCase(key);
    if (!this.filesMap[dirPath]) this.filesMap[dirPath] = '/// This file is generated by the VG SwaggerGenerator.\n/// Do not edit.\n';

    function getConstructorContent() {
      const properties = value['properties'];
      let str = '';
      for (const propertyName in properties) {
        let require = value['required']?.includes(propertyName) ?? false;
        const camelPropertyName = changeCase.camelCase(propertyName);
        str += `${INDENT}${INDENT}${require ? 'required ' : ''}this.${camelPropertyName},\n`;
      }
      str = str.length > 0 ? str.substring(4, str.length - 1) : str;
      return str;
    }

    function getPropertiesContent() {
      const properties = value['properties'];
      let str = '';
      for (const propertyName in properties) {
        const property = properties[propertyName];
        if (property.title || property.description) str += `${INDENT}/// ${property.title || property.description} \n`;
        const dartType = getDartType(propertyName, property);
        let require = value['required']?.includes(propertyName) ?? false;

        const camelPropertyName = changeCase.camelCase(propertyName);
        str += `${INDENT}${dartType}${require ? '' : ' ? '} ${camelPropertyName}; \n\n`;
      }
      str = str.length > 0 ? str.substring(2, str.length - 1) : str;
      return str;
    }

    function getFromJsonContent() {
      const properties = value['properties'];
      let str = '';
      for (const propertyName in properties) {
        const camelPropertyName = changeCase.camelCase(propertyName);
        str += `${INDENT}${INDENT}${camelPropertyName}: `;
        const property = properties[propertyName];
        const dartType = getDartType(propertyName, property);

        if (property['type'] === 'array') {
          var subType = dartType.substring(5, dartType.length - 1);
          str += `List<${subType}>.from(json["${propertyName}"].map((x) => ${BASE_TYPE.includes(subType) ? 'x' : `${subType}.fromJson(x)`})),\n`;
        } else if (!BASE_TYPE.includes(dartType)) {
          str += `${dartType}.fromJson(json["${propertyName}"]),\n`;
        } else {
          str += `json["${propertyName}"],\n`;
        }
      }
      str = str.length > 0 ? str.substring(4, str.length - 1) : str;
      return str;
    }

    function getToJsonContent() {
      const properties = value['properties'];
      let str = '';
      for (const propertyName in properties) {
        str += `${INDENT}${INDENT}"${propertyName}": `;

        const camelPropertyName = changeCase.camelCase(propertyName);
        const property = properties[propertyName];
        const dartType = getDartType(propertyName, property);
        let require = value['required']?.includes(propertyName) ?? false;
        if (property['type'] === 'array') {
          var subType = dartType.substring(5, dartType.length - 1);

          if (require)
            str += `${camelPropertyName}.map((e) => ${BASE_TYPE.includes(subType) ? 'e' : 'e.toJson()'}).toList(),\n`;
          else
            str += `${camelPropertyName} != null ? ${camelPropertyName}!.map((e) => ${BASE_TYPE.includes(subType) ? 'e' : 'e.toJson()'}).toList() : null,\n`;

        } else if (!BASE_TYPE.includes(dartType)) {
          if (require)
            str += `${camelPropertyName}.toJson(),\n`;
          else
            str += `${camelPropertyName} != null ? ${camelPropertyName}!.toJson() : null,\n`;

        } else {
          str += `${camelPropertyName},\n`;
        }
      }
      str = str.length > 0 ? str.substring(4, str.length - 1) : str;
      return str;
    }

    this.filesMap[dirPath] += `
class ${className} {
  ${className}({
    ${getConstructorContent()}
  });

  ${getPropertiesContent()}

  factory ${className}.fromJson(Map<String, dynamic> json) => ${className}(
    ${getFromJsonContent()}
  );

  Map<String, dynamic> toJson() => {
    ${getToJsonContent()}
  };
}
`;
  }


}

export default ModelGenerate;